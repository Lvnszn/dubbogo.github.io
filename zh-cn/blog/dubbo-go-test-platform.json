{
  "filename": "dubbo-go-test-platform.md",
  "__html": "<h1>背景</h1>\n<p>http 接口测试只需要一个 <code>curl</code> 命令，但 dubbo 协议没有这样的现成接口测试工具。通常公司内的 dubbo 控制台或其他平台会集成一个 dubbo 接口测试工具。</p>\n<p>调用一个 dubbo 接口，需要知道服务名 <code>service</code>、方法名 <code>method</code> 和参数 <code>args</code>。</p>\n<p>正常的调用，调用方需引入服务提供方定义的接口 jar 包。</p>\n<p>作为接口测试平台，没办法引入所有提供方定义的接口 jar 包，可以有以下方案来解决：</p>\n<ol>\n<li>dubbo 支持 telnet 协议调用 dubbo 接口</li>\n<li>dubbo 的泛化调用可以在不引入提供方接口定义 jar 包的情况下对接口进行调用</li>\n</ol>\n<p>对于方案1，实现成本很低，甚至可以在服务器上直接用 telnet 测试</p>\n<p><img src=\"../../img/blog/dubbo-go-test-platform.resources/p1.png\" alt=\"\"></p>\n<p>它也有缺点</p>\n<ul>\n<li>调用无法经过 filter</li>\n<li>无法携带隐式参数 attachment</li>\n</ul>\n<p>刚好我们把方案1的优缺点都踩了，我们的 dubbo 控制台是go语言编写，短时间快速实现，就采用了 telnet 的方式。</p>\n<p>随着业务的发展，流量染色，或标签路由等需要携带隐式参数。</p>\n<p>没有走自定义 filter，导致业务接口执行不符合预期等都迫使我们升级为泛化调用。</p>\n<p>dubbo 接口泛化调用在控制台是go编写的情况下也有两个方案可选：</p>\n<ol>\n<li>单独起一个 java 进程，暴露 http 端口，与go进程进行交互，泛化调用使用 dubbo 的 java sdk 进行编写</li>\n<li>控制台引入 dubbo-go，使用 dubbo-go 进行泛化调用</li>\n</ol>\n<p>出于对 dubbo java 版本的了解，方案1肯定可行，只是架构变得复杂。</p>\n<p>而方案2由于 dubbo-go 还是比较新的项目，并不是很了解，所以不确定其可行性和兼容性，但如果能实现，会大大降低架构的复杂度。</p>\n<h1>dubbo-go介绍</h1>\n<p>dubbo-go 是 dubbo 的 golang 实现版本，它出现的初衷是为了让 golang 和 java 的 dubbo 生态互通。</p>\n<p>如今 dubbo-go 支持 provider 和 consumer 端，可以作为一个独立的 rpc 框架使用，同时社区也是 dubbo 生态中最火的一个。</p>\n<p>如果要说它的意义，我觉得除了和java互通外还有一点非常重要，那就是它能发挥 golang <code>协程</code>的巨大作用，这一点可以用在 dubbo 网关上，如果用 dubbo-go 实现 dubbo 网关，就无需纠结线程池、异步等问题。</p>\n<h1>泛化调用的使用</h1>\n<p>首先 provider 端提供一个接口，这个不再赘述，非常简单，接口定义如下</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.newboo.basic.api;\n\n<span class=\"hljs-keyword\">import</span> org.newboo.basic.model.RpcResult;\n<span class=\"hljs-keyword\">import</span> org.newboo.basic.model.User;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyDemoService</span> </span>{\n    <span class=\"hljs-function\">RpcResult&lt;String&gt; <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(User user)</span></span>;\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.newboo.basic.model;\n\n<span class=\"hljs-keyword\">import</span> java.io.Serializable;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String uid;\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String remoteServiceTag;\n    ...\n}\n</code></pre>\n<p>再来编写 java 版的泛化调用代码，不引入 provider 方的 jar 包：</p>\n<pre><code class=\"language-java\">ReferenceConfig&lt;GenericService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;&gt;();\n<span class=\"hljs-comment\">// ①引用服务名</span>\nreference.setInterface(<span class=\"hljs-string\">\"org.newboo.basic.api.MyDemoService\"</span>);\n<span class=\"hljs-comment\">// ②设置泛化调用标志</span>\nreference.setGeneric(<span class=\"hljs-string\">\"true\"</span>);\n\nDubboBootstrap bootstrap = DubboBootstrap.getInstance();\nbootstrap.application(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"dubbo-demo-api-consumer\"</span>))\n        .registry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"zookeeper://127.0.0.1:2181\"</span>))\n        .reference(reference)\n        .start();\n\nGenericService genericService = ReferenceConfigCache.getCache().get(reference);\nString[] ps = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">1</span>];\n<span class=\"hljs-comment\">// ③参数类型</span>\nps[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"org.newboo.basic.model.User\"</span>;\nObject[] ags = <span class=\"hljs-keyword\">new</span> Object[<span class=\"hljs-number\">1</span>];\n<span class=\"hljs-comment\">// ④pojo参数使用map构造</span>\nMap&lt;String, String&gt; user = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\nuser.put(<span class=\"hljs-string\">\"uid\"</span>, <span class=\"hljs-string\">\"1\"</span>);\nuser.put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"roshi\"</span>);\nuser.put(<span class=\"hljs-string\">\"remoteServiceTag\"</span>, <span class=\"hljs-string\">\"tag\"</span>);\nags[<span class=\"hljs-number\">0</span>] = user;\n<span class=\"hljs-comment\">// ⑤发起调用</span>\nObject res = genericService.$invoke(<span class=\"hljs-string\">\"call\"</span>, ps, ags);\nSystem.out.println(res);\n</code></pre>\n<blockquote>\n<p>关键的步骤已在代码注释中标明</p>\n</blockquote>\n<p>golang 版本</p>\n<blockquote>\n<p>直接修改的 dubbo-go-samples 代码，参考 <a href=\"https://github.com/apache/dubbo-go-samples\">https://github.com/apache/dubbo-go-samples</a>\n启动时需要设置配置文件路径 ENV</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">var</span> (\n\tappName         = <span class=\"hljs-string\">\"UserConsumer\"</span>\n\treferenceConfig = config.ReferenceConfig{\n\t\tInterfaceName: <span class=\"hljs-string\">\"org.newboo.basic.api.MyDemoService\"</span>,\n\t\tCluster:       <span class=\"hljs-string\">\"failover\"</span>,\n    <span class=\"hljs-comment\">// registry需要配置文件</span>\n\t\tRegistry:      <span class=\"hljs-string\">\"demoZk\"</span>,\n\t\tProtocol:      dubbo.DUBBO,\n\t\tGeneric:       <span class=\"hljs-literal\">true</span>,\n\t}\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span> {\n\treferenceConfig.GenericLoad(appName) <span class=\"hljs-comment\">//appName is the unique identification of RPCService</span>\n\ttime.Sleep(<span class=\"hljs-number\">1</span> * time.Second)\n}\n\n<span class=\"hljs-comment\">// need to setup environment variable \"CONF_CONSUMER_FILE_PATH\" to \"conf/client.yml\" before run</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tcall()\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-comment\">// 设置attachment</span>\n\tctx := context.WithValue(context.TODO(), constant.AttachmentKey, <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"tag\"</span>:<span class=\"hljs-string\">\"test\"</span>})\n\n\tresp, err := referenceConfig.GetRPCService().(*config.GenericService).Invoke(\n\t\tctx,\n\t\t[]<span class=\"hljs-keyword\">interface</span>{}{\n\t\t\t<span class=\"hljs-string\">\"call\"</span>,\n\t\t\t[]<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"org.newboo.basic.model.User\"</span>},\n\t\t\t[]<span class=\"hljs-keyword\">interface</span>{}{<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"uid\"</span>:<span class=\"hljs-string\">\"111\"</span>,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"roshi\"</span>,<span class=\"hljs-string\">\"remoteServiceTag\"</span>:<span class=\"hljs-string\">\"hello\"</span>}},\n\t\t},\n\t)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(err)\n\t}\n\tgxlog.CInfo(<span class=\"hljs-string\">\"success called res: %+v\\n\"</span>, resp)\n}\n</code></pre>\n<p>这里我设置了一个 attachment，也能正常被 provider 识别</p>\n<p><img src=\"../../img/blog/dubbo-go-test-platform.resources/p2.png\" alt=\"\"></p>\n<h1>泛化调用原理</h1>\n<p>泛化调用 <code>GenericService</code> 是 dubbo 默认提供的一个服务。</p>\n<p>其提供了一个名为 <code>$invoke</code> 的方法，该方法参数有三个，第一个参数是真实要调用的方法名，第二个是参数类型数组，第三个是真实的参数数组，其定义为</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GenericService</span> </span>{\n    Object $invoke(String method, String[] parameterTypes, Object[] args) <span class=\"hljs-keyword\">throws</span> GenericException;\n    ...\n}\n</code></pre>\n<p>有了这三个参数，利用反射就能调用到真实的接口了。</p>\n<h3>java版实现细节</h3>\n<p>实现这种泛化调用主要涉及到两个 filter：</p>\n<ul>\n<li>consumer 端的 GenericImplFilter</li>\n<li>provider 端的 GenericFilter</li>\n</ul>\n<p>consumer 端的 filter 将 generic 标志设置到 attachment 中，并封装调用为 <code>GenericService.$invoke</code></p>\n<p>provider 端 filter 判断请求是 generic 时进行拦截，获取调用方法名、参数、参数值，先序列化为 pojo 对象，再进行反射调用真实接口。</p>\n<h3>dubbo-go版细节</h3>\n<p>与 java 实现基本一致，其中 generic_filter 充当 consumer 端的 filter，也是将调用封装为 GenericService.$invoke，其中还涉及到一个参数类型的转换，将 map 转换为 <code>dubbo-go-hessian2.Object</code>，这样 provider 端就可以将其反序列化为 Object 对象。</p>\n<p>与其相关的版本变更如下</p>\n<ul>\n<li>v1.3.0 开始支持泛化调用</li>\n<li>v1.4.0 开始支持用户设置 attachement</li>\n<li>v1.5.1 开始支持动态 tag 路由</li>\n<li>v1.5.7-rc1 修复了直连 provider 时无法走 filter 的 bug</li>\n</ul>\n<blockquote>\n<p>踩坑：v1.5.7-rc1 之前如果使用直连 provider 的方式，不会走 filter，导致参数序列化出错，provider 端会报类型转换异常</p>\n</blockquote>\n<h1>结论</h1>\n<p>dubbo-go 的泛化调用推荐使用 &gt;=v1.5.7-rc1 版本，其功能几乎已和 java 版打平，甚至其实现都与 java 类似。</p>\n<p>使用 dubbo-go 构建网关、接口测试平台、或者打通 golang 与 java 技术生态，不失为一个好的选择。</p>\n<hr>\n<blockquote>\n<p>作者简介</p>\n<p><strong>李康</strong> (GitHubID lkxiaolou)，目前就职于滴滴出行基础架构部，公众号 <strong>捉虫大师</strong> 作者</p>\n</blockquote>\n",
  "link": "/zh-cn/blog/dubbo-go-test-platform.html",
  "meta": {
    "title": "使用 dubbo-go 搭建 dubbo 接口测试平台",
    "keywords": "\"dubbo-go\", \"dubbo 接口测试\"",
    "description": "本文介绍了滴滴出行使用 dubbo-go 搭建 dubbo 接口测试平台的实践"
  }
}