{
  "filename": "dubbo-go-code-notes-2.md",
  "__html": "<h2>前言</h2>\n<p>有了上一篇文章[《dubbo-go 源码笔记（一）Server服务暴露过程详解》]({{&lt;ref &quot;/blog/news/dubbo-go-codewalk-1.md&quot; &gt;}} &quot;&quot;) 的铺垫，可以大致上类比客户端服务类似于服务端启动过程。其中最大的区别是服务端通过zk注册服务，发布自己的ivkURL并订阅事件开启监听；而服务端应该是通过zk注册组件，<strong>拿到需要调用的serviceURL</strong>，<strong>更新invoker</strong>并<strong>重写用户的RPCService</strong>，从而实现对远程过程调用细节的封装。</p>\n<h2>1. 配置文件和客户端源码</h2>\n<h4>1.1 client配置文件</h4>\n<p>helloworld提供的demo：profiles/client.yaml</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">registries :</span>\n  <span class=\"hljs-attr\">\"demoZk\":</span>\n    <span class=\"hljs-attr\">protocol:</span> <span class=\"hljs-string\">\"zookeeper\"</span>\n    <span class=\"hljs-attr\">timeout :</span> <span class=\"hljs-string\">\"3s\"</span>\n    <span class=\"hljs-attr\">address:</span> <span class=\"hljs-string\">\"127.0.0.1:2181\"</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">\"\"</span>\n<span class=\"hljs-attr\">references:</span>\n  <span class=\"hljs-attr\">\"UserProvider\":</span>\n    <span class=\"hljs-comment\"># 可以指定多个registry，使用逗号隔开;不指定默认向所有注册中心注册</span>\n    <span class=\"hljs-attr\">registry:</span> <span class=\"hljs-string\">\"demoZk\"</span>\n    <span class=\"hljs-attr\">protocol :</span> <span class=\"hljs-string\">\"dubbo\"</span>\n    <span class=\"hljs-attr\">interface :</span> <span class=\"hljs-string\">\"com.ikurento.user.UserProvider\"</span>\n    <span class=\"hljs-attr\">cluster:</span> <span class=\"hljs-string\">\"failover\"</span>\n    <span class=\"hljs-attr\">methods :</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"GetUser\"</span>\n      <span class=\"hljs-attr\">retries:</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>可看到配置文件与之前讨论过的server端非常类似，其refrences部分字段就是对当前服务要主调的服务的配置，其中详细说明了调用协议、注册协议、接口id、调用方法、集群策略等，这些配置都会在之后与注册组件交互，重写ivk、调用的过程中使用到。</p>\n<h4>1.2 客户端使用框架源码</h4>\n<p>user.go</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span> {\n    config.SetConsumerService(userProvider)\n    hessian.RegisterPOJO(&amp;User{})\n}\n</code></pre>\n<p>main.go</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    hessian.RegisterPOJO(&amp;User{})\n    config.Load()\n    time.Sleep(<span class=\"hljs-number\">3e9</span>)\n    <span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"\\n\\n\\nstart to test dubbo\"</span>)\n    user := &amp;User{}\n    err := userProvider.GetUser(context.TODO(), []<span class=\"hljs-keyword\">interface</span>{}{<span class=\"hljs-string\">\"A001\"</span>}, user)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n      <span class=\"hljs-built_in\">panic</span>(err)\n    }\n    <span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"response result: %v\\n\"</span>, user)\n    initSignal()\n}\n</code></pre>\n<p>官网提供的helloworld demo的源码。可看到与服务端类似，在user.go内注册了rpc-service，以及需要rpc传输的结构体user。</p>\n<p>在main函数中，同样调用了config.Load()函数，之后就可以直接通过实现好的rpc-service：userProvider 直接调用对应的功能函数，即可实现rpc调用。</p>\n<p>可以猜到，从hessian注册结构、SetConsumerService，到调用函数.GetUser()期间，用户定义的rpc-service也就是userProvider对应的函数被重写，重写后的GetUser函数已经包含了实现了远程调用逻辑的invoker。</p>\n<p>接下来，就要通过阅读源码，看看dubbo-go是如何做到的。</p>\n<h2>2. 实现远程过程调用</h2>\n<h4>2.1 加载配置文件</h4>\n<p>config/config_loader.go :Load()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Load Dubbo Init</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Load</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// init router</span>\n    initRouter()\n    <span class=\"hljs-comment\">// init the global event dispatcher</span>\n    extension.SetAndInitGlobalDispatcher(GetBaseConfig().EventDispatcherType)\n    <span class=\"hljs-comment\">// start the metadata report if config set</span>\n    <span class=\"hljs-keyword\">if</span> err := startMetadataReport(GetApplicationConfig().MetadataType, GetBaseConfig().MetadataReportConfig); err != <span class=\"hljs-literal\">nil</span> {\n      logger.Errorf(<span class=\"hljs-string\">\"Provider starts metadata report error, and the error is {%#v}\"</span>, err)\n  <span class=\"hljs-keyword\">return</span>\n    }\n    <span class=\"hljs-comment\">// reference config</span>\n    loadConsumerConfig()\n</code></pre>\n<p>在main函数中调用的config.Load()函数，进而调用了loadConsumerConfig，类似于之前讲到的server端配置读入函数。</p>\n<p>在loadConsumerConfig函数中，进行了三步操作：</p>\n<p><img src=\"/imgs/blog/dubbo-go/code2/p1.png\" alt=\"\"></p>\n<ol>\n<li>检查配置文件并将配置写入内存</li>\n<li><strong>在for循环内部</strong>，依次引用（refer）并且实例化（implement）每个被调reference。</li>\n<li>等待三秒钟所有invoker就绪</li>\n</ol>\n<p>其中重要的就是for循环里面的引用和实例化，两步操作，会在接下来展开讨论。</p>\n<p>至此，配置已经被写入了框架。</p>\n<h4>2.2 获取远程Service URL，实现可供调用的invoker</h4>\n<p>上述的ref.Refer完成的就是这部分的操作。</p>\n<p>图（一）</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p2.png\" alt=\"\"></p>\n<h5>2.2.1 构造注册url</h5>\n<p>和server端类似，存在注册url和服务url，dubbo习惯将服务url作为注册url的sub。</p>\n<p>config/reference_config.go: Refer()</p>\n<pre><code class=\"language-go\">/ Refer ...\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *ReferenceConfig)</span> <span class=\"hljs-title\">Refer</span><span class=\"hljs-params\">(_ <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n    <span class=\"hljs-comment\">//（一）配置url参数(serviceUrl)，将会作为sub</span>\n    cfgURL := common.NewURLWithOptions(\n  common.WithPath(c.id),\n  common.WithProtocol(c.Protocol),\n  common.WithParams(c.getUrlMap()),\n  common.WithParamsValue(constant.BEAN_NAME_KEY, c.id),\n    )\n    ...\n    <span class=\"hljs-comment\">// （二）注册地址可以通过url格式给定，也可以通过配置格式给定</span>\n    <span class=\"hljs-comment\">// 这一步的意义就是配置-&gt;提取信息生成URL</span>\n    <span class=\"hljs-keyword\">if</span> c.Url != <span class=\"hljs-string\">\"\"</span> {<span class=\"hljs-comment\">// 用户给定url信息，可以是点对点的地址，也可以是注册中心的地址</span>\n  <span class=\"hljs-comment\">// 1. user specified URL, could be peer-to-peer address, or register center's address.</span>\n  urlStrings := gxstrings.RegSplit(c.Url, <span class=\"hljs-string\">\"\\\\s*[;]+\\\\s*\"</span>)\n  <span class=\"hljs-keyword\">for</span> _, urlStr := <span class=\"hljs-keyword\">range</span> urlStrings {\n    serviceUrl, err := common.NewURL(urlStr)\n    ...\n  }\n    } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">// 配置读入注册中心的信息</span>\n  <span class=\"hljs-comment\">//  assemble SubURL from register center's configuration mode</span>\n  <span class=\"hljs-comment\">// 这是注册url，protocol = registry,包含了zk的用户名、密码、ip等等</span>\n  c.urls = loadRegistries(c.Registry, consumerConfig.Registries, common.CONSUMER)\n  ...\n  <span class=\"hljs-comment\">// set url to regUrls</span>\n  <span class=\"hljs-keyword\">for</span> _, regUrl := <span class=\"hljs-keyword\">range</span> c.urls {\n    regUrl.SubURL = cfgURL<span class=\"hljs-comment\">// regUrl的subURl存当前配置url</span>\n  }\n    }\n    <span class=\"hljs-comment\">//至此，无论通过什么形式，已经拿到了全部的regURL</span>\n    <span class=\"hljs-comment\">// （三）获取registryProtocol实例，调用其Refer方法，传入新构建好的regURL</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.urls) == <span class=\"hljs-number\">1</span> {\n  <span class=\"hljs-comment\">// 这一步访问到registry/protocol/protocol.go registryProtocol.Refer</span>\n  <span class=\"hljs-comment\">// 这里是registry</span>\n  c.invoker = extension.GetProtocol(c.urls[<span class=\"hljs-number\">0</span>].Protocol).Refer(*c.urls[<span class=\"hljs-number\">0</span>])\n    } <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// 如果有多个注册中心，即有多个invoker,则采取集群策略</span>\n  invokers := <span class=\"hljs-built_in\">make</span>([]protocol.Invoker, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(c.urls))\n  ...\n    }\n</code></pre>\n<p>这个函数中，已经处理完从Register配置到RegisterURL的转换,即图（一）中部分：</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p3.png\" alt=\"\"></p>\n<p>接下来，已经拿到的url将被传递给RegistryProtocol，进一步refer。</p>\n<h5>2.2.2 registryProtocol获取到zkRegistry实例，进一步Refer</h5>\n<p>registry/protocol/protocol.go: Refer</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Refer provider service from registry center</span>\n<span class=\"hljs-comment\">// 拿到的是配置文件registries的url，他能够生成一个invoker = 指向目的addr，以供客户端直接调用。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(proto *registryProtocol)</span> <span class=\"hljs-title\">Refer</span><span class=\"hljs-params\">(url common.URL)</span> <span class=\"hljs-title\">protocol</span>.<span class=\"hljs-title\">Invoker</span></span> {\n    <span class=\"hljs-keyword\">var</span> registryUrl = url\n    <span class=\"hljs-comment\">// 这里拿到的是referenceConfig，serviceUrl里面包含了Reference的所有信息，包含interfaceName、method等等</span>\n    <span class=\"hljs-keyword\">var</span> serviceUrl = registryUrl.SubURL\n    <span class=\"hljs-keyword\">if</span> registryUrl.Protocol == constant.REGISTRY_PROTOCOL {<span class=\"hljs-comment\">// registryUrl.Proto = \"registry\"</span>\n  protocol := registryUrl.GetParam(constant.REGISTRY_KEY, <span class=\"hljs-string\">\"\"</span>)\n  registryUrl.Protocol = protocol<span class=\"hljs-comment\">//替换成了具体的值，比如\"zookeeper\"</span>\n    }\n    <span class=\"hljs-comment\">// 接口对象</span>\n    <span class=\"hljs-keyword\">var</span> reg registry.Registry\n    <span class=\"hljs-comment\">// （一）实例化接口对象，缓存策略</span>\n    <span class=\"hljs-keyword\">if</span> regI, loaded := proto.registries.Load(registryUrl.Key()); !loaded {\n  <span class=\"hljs-comment\">// 缓存中不存在当前registry，新建一个reg</span>\n  reg = getRegistry(&amp;registryUrl)\n  <span class=\"hljs-comment\">// 缓存起来</span>\n  proto.registries.Store(registryUrl.Key(), reg)\n    } <span class=\"hljs-keyword\">else</span> {\n  reg = regI.(registry.Registry)\n    }\n    <span class=\"hljs-comment\">// 到这里，获取到了reg实例 zookeeper的registry</span>\n    <span class=\"hljs-comment\">//（二）根据Register的实例zkRegistry和传入的regURL新建一个directory</span>\n    <span class=\"hljs-comment\">// 这一步存在复杂的异步逻辑，从注册中心拿到了目的service的真实addr，获取了invoker并放入directory，</span>\n    <span class=\"hljs-comment\">// 这一步将在下面详细给出步骤</span>\n    <span class=\"hljs-comment\">// new registry directory for store service url from registry</span>\n    directory, err := extension.GetDefaultRegistryDirectory(&amp;registryUrl, reg)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n  logger.Errorf(<span class=\"hljs-string\">\"consumer service %v  create registry directory  error, error message is %s, and will return nil invoker!\"</span>,\n    serviceUrl.String(), err.Error())\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n    }\n    <span class=\"hljs-comment\">// （三）DoRegister 在zk上注册当前client service</span>\n    err = reg.Register(*serviceUrl)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n  logger.Errorf(<span class=\"hljs-string\">\"consumer service %v register registry %v error, error message is %s\"</span>,\n    serviceUrl.String(), registryUrl.String(), err.Error())\n    }\n    <span class=\"hljs-comment\">// （四）new cluster invoker，将directory写入集群，获得具有集群策略的invoker</span>\n    cluster := extension.GetCluster(serviceUrl.GetParam(constant.CLUSTER_KEY, constant.DEFAULT_CLUSTER))\n    invoker := cluster.Join(directory)\n    <span class=\"hljs-comment\">// invoker保存</span>\n    proto.invokers = <span class=\"hljs-built_in\">append</span>(proto.invokers, invoker)\n    <span class=\"hljs-keyword\">return</span> invoker\n}\n</code></pre>\n<p>可详细阅读上述注释，这个函数完成了从url到invoker的全部过程</p>\n<p>（一）首先获得Registry对象，默认是之前实例化的zkRegistry，和之前server获取Registry的处理很类似。\n（二）通过构造一个新的directory，异步拿到之前在zk上注册的server端信息，生成invoker\n（三）在zk上注册当前service\n（四）集群策略，获得最终invoker</p>\n<p>这一步完成了图（一）中所有余下的绝大多数操作，接下来就需要详细的查看directory的构造过程：</p>\n<h5>2.2.3 构造directory（包含较复杂的异步操作）</h5>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p4.png\" alt=\"\"></p>\n<p>图（二）</p>\n<p>上述的 <code>extension.GetDefaultRegistryDirectory(&amp;registryUrl, reg)</code>函数，本质上调用了已经注册好的<code>NewRegistryDirectory</code>函数:</p>\n<p>registry/directory/directory.go: NewRegistryDirectory()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// NewRegistryDirectory will create a new RegistryDirectory</span>\n<span class=\"hljs-comment\">// 这个函数作为default注册在extension上面</span>\n<span class=\"hljs-comment\">// url为注册url，reg为zookeeper registry</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewRegistryDirectory</span><span class=\"hljs-params\">(url *common.URL, registry registry.Registry)</span> <span class=\"hljs-params\">(cluster.Directory, error)</span></span> {\n    <span class=\"hljs-keyword\">if</span> url.SubURL == <span class=\"hljs-literal\">nil</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, perrors.Errorf(<span class=\"hljs-string\">\"url is invalid, suburl can not be nil\"</span>)\n    }\n    dir := &amp;RegistryDirectory{\n  BaseDirectory:    directory.NewBaseDirectory(url),\n  cacheInvokers:    []protocol.Invoker{},\n  cacheInvokersMap: &amp;sync.Map{},\n  serviceType:      url.SubURL.Service(),\n  registry:         registry,\n    }\n    dir.consumerConfigurationListener = newConsumerConfigurationListener(dir)\n    <span class=\"hljs-keyword\">go</span> dir.subscribe(url.SubURL)\n    <span class=\"hljs-keyword\">return</span> dir, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>首先构造了一个注册directory，开启携程调用其subscribe函数，传入serviceURL。</p>\n<p>这个directory目前包含了对应的zkRegistry，以及传入的URL，他cacheInvokers的部分是空的。</p>\n<p>进入dir.subscribe(url.SubURL)这个异步函数：</p>\n<p>registry/directory/directory.go: subscribe()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// subscribe from registry</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dir *RegistryDirectory)</span> <span class=\"hljs-title\">subscribe</span><span class=\"hljs-params\">(url *common.URL)</span></span> {\n    <span class=\"hljs-comment\">// 增加两个监听，</span>\n    dir.consumerConfigurationListener.addNotifyListener(dir)\n    dir.referenceConfigurationListener = newReferenceConfigurationListener(dir, url)\n    <span class=\"hljs-comment\">// subscribe调用</span>\n    dir.registry.Subscribe(url, dir)\n}\n</code></pre>\n<p>重点来了，他调用了zkRegistry的Subscribe方法,与此同时将自己作为ConfigListener传入</p>\n<blockquote>\n<p>我认为这种传入listener的设计模式非常值得学习，而且很有java的味道。</p>\n<p>针对等待zk返回订阅信息这样的异步操作，需要传入一个Listener，这个Listener需要实现Notify方法，进而在作为参数传入内部之后，可以被异步地调用Notify，将内部触发的异步事件“传递出来”，再进一步处理加工。</p>\n<p>层层的Listener事件链，能将传入的原始serviceURL通过zkConn发送给zk服务，获取到服务端注册好的url对应的二进制信息。</p>\n<p>而Notify回调链，则将这串byte[]一步一步解析、加工；以事件的形式向外传递，最终落到directory上的时候，已经是成型的newInvokers了。</p>\n<p>具体细节不再以源码形式展示，可参照上图查阅源码。</p>\n</blockquote>\n<p>至此已经拿到了server端注册好的真实invoker。</p>\n<p>完成了图（一）中的部分：</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p5.png\" alt=\"\"></p>\n<h5>2.2.4 构造带有集群策略的clusterinvoker</h5>\n<p>经过上述操作，已经拿到了server端Invokers，放入了directory的cacheinvokers数组里面缓存。</p>\n<p>后续的操作对应本文2.2.2的第四步，由directory生成带有特性集群策略的invoker</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// （四）new cluster invoker，将directory写入集群，获得具有集群策略的invoker</span>\n    cluster := extension.GetCluster(serviceUrl.GetParam(constant.CLUSTER_KEY, constant.DEFAULT_CLUSTER))\n    invoker := cluster.Join(directory)\n<span class=\"hljs-number\">123</span>\n</code></pre>\n<p>Join函数的实现就是如下函数：</p>\n<p>cluster/cluster_impl/failover_cluster_invokers.go: newFailoverClusterInvoker()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newFailoverClusterInvoker</span><span class=\"hljs-params\">(directory cluster.Directory)</span> <span class=\"hljs-title\">protocol</span>.<span class=\"hljs-title\">Invoker</span></span> {\n    <span class=\"hljs-keyword\">return</span> &amp;failoverClusterInvoker{\n  baseClusterInvoker: newBaseClusterInvoker(directory),\n    }\n}\n<span class=\"hljs-number\">12345</span>\n</code></pre>\n<p>dubbo-go框架默认选择failover策略，既然返回了一个invoker，我们查看一下failoverClusterInvoker的Invoker方法，看他是如何将集群策略封装到Invoker函数内部的：</p>\n<p>cluster/cluster_impl/failover_cluster_invokers.go: Invoker()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Invoker 函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(invoker *failoverClusterInvoker)</span> <span class=\"hljs-title\">Invoke</span><span class=\"hljs-params\">(ctx context.Context, invocation protocol.Invocation)</span> <span class=\"hljs-title\">protocol</span>.<span class=\"hljs-title\">Result</span></span> {\n    ...\n    <span class=\"hljs-comment\">//调用List方法拿到directory缓存的所有invokers</span>\n    invokers := invoker.directory.List(invocation)\n    <span class=\"hljs-keyword\">if</span> err := invoker.checkInvokers(invokers, invocation); err != <span class=\"hljs-literal\">nil</span> {<span class=\"hljs-comment\">// 检查是否可以实现调用</span>\n  <span class=\"hljs-keyword\">return</span> &amp;protocol.RPCResult{Err: err}\n    }\n    <span class=\"hljs-comment\">// 获取来自用户方向传入的</span>\n    methodName := invocation.MethodName()\n    retries := getRetries(invokers, methodName)\n    loadBalance := getLoadBalance(invokers[<span class=\"hljs-number\">0</span>], invocation)\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt;= retries; i++ {\n  <span class=\"hljs-comment\">// 重要！这里是集群策略的体现，失败后重试！</span>\n  <span class=\"hljs-comment\">//Reselect before retry to avoid a change of candidate `invokers`.</span>\n  <span class=\"hljs-comment\">//<span class=\"hljs-doctag\">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span>\n  <span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> {\n    <span class=\"hljs-keyword\">if</span> err := invoker.checkWhetherDestroyed(); err != <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-keyword\">return</span> &amp;protocol.RPCResult{Err: err}\n    }\n    invokers = invoker.directory.List(invocation)\n    <span class=\"hljs-keyword\">if</span> err := invoker.checkInvokers(invokers, invocation); err != <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-keyword\">return</span> &amp;protocol.RPCResult{Err: err}\n    }\n  }\n  <span class=\"hljs-comment\">// 这里是负载均衡策略的体现！选择特定ivk进行调用。</span>\n  ivk := invoker.doSelect(loadBalance, invocation, invokers, invoked)\n  <span class=\"hljs-keyword\">if</span> ivk == <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-keyword\">continue</span>\n  }\n  invoked = <span class=\"hljs-built_in\">append</span>(invoked, ivk)\n  <span class=\"hljs-comment\">//DO INVOKE</span>\n  result = ivk.Invoke(ctx, invocation)\n  <span class=\"hljs-keyword\">if</span> result.Error() != <span class=\"hljs-literal\">nil</span> {\n    providers = <span class=\"hljs-built_in\">append</span>(providers, ivk.GetUrl().Key())\n    <span class=\"hljs-keyword\">continue</span>\n  }\n  <span class=\"hljs-keyword\">return</span> result\n    }\n    ...\n}\n</code></pre>\n<blockquote>\n<p>看了很多Invoke函数的实现，所有类似的Invoker函数都包含两个方向，一个是用户方向的invcation，一个是函数方向的底层invokers。</p>\n<p>而集群策略的invoke函数本身作为接线员，把invocation一步步解析，根据调用需求和集群策略，选择特定的invoker来执行</p>\n<p>proxy函数也是这样，一个是用户方向的ins[] reflect.Type, 一个是函数方向的invoker。</p>\n<p>proxy函数负责将ins转换为invocation，调用对应invoker的invoker函数，实现连通。</p>\n<p>而出于这样的设计，可以在一步步Invoker封装的过程中，每个Invoker只关心自己负责操作的部分，从而使整个调用栈解耦。</p>\n<p>妙啊！！！</p>\n</blockquote>\n<p>至此，我们理解了failoverClusterInvoker 的Invoke函数实现，也正是和这个集群策略Invoker被返回，接受来自上方的调用。</p>\n<p>已完成图（一）中的：</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p6.png\" alt=\"\"></p>\n<h5>2.2.5 在zookeeper上注册当前client</h5>\n<p>拿到invokers后，可以回到：</p>\n<p>config/refrence_config.go: Refer()函数了。</p>\n<pre><code class=\"language-go\">    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.urls) == <span class=\"hljs-number\">1</span> {\n  <span class=\"hljs-comment\">// 这一步访问到registry/protocol/protocol.go registryProtocol.Refer</span>\n  c.invoker = extension.GetProtocol(c.urls[<span class=\"hljs-number\">0</span>].Protocol).Refer(*c.urls[<span class=\"hljs-number\">0</span>])\n  <span class=\"hljs-comment\">// （一）拿到了真实的invokers</span>\n    } <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// 如果有多个注册中心，即有多个invoker,则采取集群策略</span>\n  invokers := <span class=\"hljs-built_in\">make</span>([]protocol.Invoker, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(c.urls))\n  ...\n  cluster := extension.GetCluster(hitClu)\n  <span class=\"hljs-comment\">// If 'zone-aware' policy select, the invoker wrap sequence would be:</span>\n  <span class=\"hljs-comment\">// ZoneAwareClusterInvoker(StaticDirectory) -&gt;</span>\n  <span class=\"hljs-comment\">// FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span>\n  c.invoker = cluster.Join(directory.NewStaticDirectory(invokers))\n    }\n    <span class=\"hljs-comment\">// （二）create proxy，为函数配置代理</span>\n    <span class=\"hljs-keyword\">if</span> c.Async {\n  callback := GetCallback(c.id)\n  c.pxy = extension.GetProxyFactory(consumerConfig.ProxyFactory).GetAsyncProxy(c.invoker, callback, cfgURL)\n    } <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// 这里c.invoker已经是目的addr了</span>\n  c.pxy = extension.GetProxyFactory(consumerConfig.ProxyFactory).GetProxy(c.invoker, cfgURL)\n    }\n</code></pre>\n<p>我们有了可以打通的invokers，但还不能直接调用，因为invoker的入参是invocation，而调用函数使用的是具体的参数列表。需要通过一层proxy来规范入参和出参。</p>\n<p>接下来新建一个默认proxy，放置在c.proxy内，以供后续使用</p>\n<p>至此，完成了图（一）中最后的操作</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p7.png\" alt=\"\"></p>\n<h3>2.3 将调用逻辑以代理函数的形式写入rpc-service</h3>\n<p>上面完成了config.Refer操作</p>\n<p>回到config/config_loader.go: loadConsumerConfig()</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p8.png\" alt=\"\"></p>\n<p>下一个重要的函数是Implement，他完的操作较为简单：旨在使用上面生成的c.proxy代理，链接用户自己定义的rpcService到clusterInvoker的信息传输。</p>\n<p>函数较长，只选取了重要的部分:</p>\n<p>common/proxy/proxy.go: Implement()</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Implement</span>\n<span class=\"hljs-comment\">// proxy implement</span>\n<span class=\"hljs-comment\">// In consumer, RPCService like:</span>\n<span class=\"hljs-comment\">//      type XxxProvider struct {</span>\n<span class=\"hljs-comment\">//    Yyy func(ctx context.Context, args []interface{}, rsp *Zzz) error</span>\n<span class=\"hljs-comment\">//      }</span>\n<span class=\"hljs-comment\">// Implement 实现的过程，就是proxy根据函数名和返回值，通过调用invoker 构造出拥有远程调用逻辑的代理函数</span>\n<span class=\"hljs-comment\">// 将当前rpc所有可供调用的函数注册到proxy.rpc内</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *Proxy)</span> <span class=\"hljs-title\">Implement</span><span class=\"hljs-params\">(v common.RPCService)</span></span> {\n    <span class=\"hljs-comment\">// makeDubboCallProxy 这是一个构造代理函数，这个函数的返回值是func(in []reflect.Value) []reflect.Value 这样一个函数</span>\n    <span class=\"hljs-comment\">// 这个被返回的函数是请求实现的载体，由他来发起调用获取结果</span>\n    makeDubboCallProxy := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(methodName <span class=\"hljs-keyword\">string</span>, outs []reflect.Type)</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(in []reflect.Value)</span> []<span class=\"hljs-title\">reflect</span>.<span class=\"hljs-title\">Value</span></span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(in []reflect.Value)</span> []<span class=\"hljs-title\">reflect</span>.<span class=\"hljs-title\">Value</span></span> {\n    <span class=\"hljs-comment\">// 根据methodName和outs的类型，构造这样一个函数，这个函数能将in 输入的value转换为输出的value</span>\n    <span class=\"hljs-comment\">// 这个函数具体的实现如下：</span>\n    ...\n    <span class=\"hljs-comment\">// 目前拿到了 methodName、所有入参的interface和value，出参数reply</span>\n    <span class=\"hljs-comment\">// （一）根据这些生成一个 rpcinvocation</span>\n    inv = invocation_impl.NewRPCInvocationWithOptions(\n    invocation_impl.WithMethodName(methodName),\n    invocation_impl.WithArguments(inIArr),\n    invocation_impl.WithReply(reply.Interface()),\n    invocation_impl.WithCallBack(p.callBack),\n    invocation_impl.WithParameterValues(inVArr))\n    <span class=\"hljs-keyword\">for</span> k, value := <span class=\"hljs-keyword\">range</span> p.attachments {\n    inv.SetAttachments(k, value)\n    }\n    <span class=\"hljs-comment\">// add user setAttachment</span>\n    atm := invCtx.Value(constant.AttachmentKey) <span class=\"hljs-comment\">// 如果传入的ctx里面有attachment，也要写入inv</span>\n    <span class=\"hljs-keyword\">if</span> m, ok := atm.(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>); ok {\n    <span class=\"hljs-keyword\">for</span> k, value := <span class=\"hljs-keyword\">range</span> m {\n        inv.SetAttachments(k, value)\n    }\n    }\n    <span class=\"hljs-comment\">// 至此构造inv完毕</span>\n    <span class=\"hljs-comment\">// (二）触发Invoker 之前已经将cluster_invoker放入proxy，使用Invoke方法，通过getty远程过程调用</span>\n    result := p.invoke.Invoke(invCtx, inv)\n    <span class=\"hljs-comment\">// 如果有attachment，则加入</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(result.Attachments()) &gt; <span class=\"hljs-number\">0</span> {\n    invCtx = context.WithValue(invCtx, constant.AttachmentKey, result.Attachments())\n    }\n    ...\n  }\n    }\n    numField := valueOfElem.NumField()\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; numField; i++ {\n  t := typeOf.Field(i)\n  methodName := t.Tag.Get(<span class=\"hljs-string\">\"dubbo\"</span>)\n  <span class=\"hljs-keyword\">if</span> methodName == <span class=\"hljs-string\">\"\"</span> {\n    methodName = t.Name\n  }\n  f := valueOfElem.Field(i)\n  <span class=\"hljs-keyword\">if</span> f.Kind() == reflect.Func &amp;&amp; f.IsValid() &amp;&amp; f.CanSet() { <span class=\"hljs-comment\">// 针对于每个函数</span>\n    outNum := t.Type.NumOut()\n    <span class=\"hljs-comment\">// 规定函数输出只能有1/2个</span>\n    <span class=\"hljs-keyword\">if</span> outNum != <span class=\"hljs-number\">1</span> &amp;&amp; outNum != <span class=\"hljs-number\">2</span> {\n    logger.Warnf(<span class=\"hljs-string\">\"method %s of mtype %v has wrong number of in out parameters %d; needs exactly 1/2\"</span>,\n        t.Name, t.Type.String(), outNum)\n    <span class=\"hljs-keyword\">continue</span>\n    }\n    <span class=\"hljs-comment\">// The latest return type of the method must be error.</span>\n    <span class=\"hljs-comment\">// 规定最后一个返回值一定是error</span>\n    <span class=\"hljs-keyword\">if</span> returnType := t.Type.Out(outNum - <span class=\"hljs-number\">1</span>); returnType != typError {\n    logger.Warnf(<span class=\"hljs-string\">\"the latest return type %s of method %q is not error\"</span>, returnType, t.Name)\n    <span class=\"hljs-keyword\">continue</span>\n    }\n    <span class=\"hljs-comment\">// 获取到所有的出参类型，放到数组里</span>\n    <span class=\"hljs-keyword\">var</span> funcOuts = <span class=\"hljs-built_in\">make</span>([]reflect.Type, outNum)\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; outNum; i++ {\n    funcOuts[i] = t.Type.Out(i)\n    }\n    <span class=\"hljs-comment\">// do method proxy here:</span>\n    <span class=\"hljs-comment\">// （三）调用make函数，传入函数名和返回值，获得能调用远程的proxy，将这个proxy替换掉原来的函数位置</span>\n    f.Set(reflect.MakeFunc(f.Type(), makeDubboCallProxy(methodName, funcOuts)))\n    logger.Debugf(<span class=\"hljs-string\">\"set method [%s]\"</span>, methodName)\n  }\n    }\n    ...\n}\n</code></pre>\n<p>正如之前所说，proxy的作用是将用户定义的函数参数列表，转化为抽象的invocation传入Invoker，进行调用。</p>\n<p>其中已标明有三处较为重要的地方：</p>\n<ol>\n<li>在代理函数中实现由参数列表生成Invocation的逻辑</li>\n<li>在代理函数实现调用Invoker的逻辑</li>\n<li>将代理函数替换为原始rpc-service对应函数\n至此，也就解决了一开始的问题：\nclient.go: main()</li>\n</ol>\n<pre><code class=\"language-go\">    config.Load()\n    user := &amp;User{}\n    err := userProvider.GetUser(context.TODO(), []<span class=\"hljs-keyword\">interface</span>{}{<span class=\"hljs-string\">\"A001\"</span>}, user)\n</code></pre>\n<p>这里直接调用用户定义的rpcService的函数GetUser，这里实际调用的是经过重写入的函数代理，所以就能实现远程调用了。</p>\n<h3>3. 从client到server的invoker嵌套链- 小结</h3>\n<p>在阅读dubbo-go源码的过程中，我能发现一条清晰的invoker-proxy嵌套链，我希望通过图的形式来展现：</p>\n<p><img src=\"img/blog/dubbo-go-code-notes-2.resource/p9.png\" alt=\"\"></p>\n<blockquote>\n<p>作者简介 李志信 (GitHubID LaurenceLiZhixin)，中山大学软件工程专业在校学生，擅长使用 Java/Go 语言，专注于云原生和微服务等技术方向。</p>\n</blockquote>\n",
  "link": "/zh-cn/blog/dubbo-go-code-notes-2.html",
  "meta": {
    "title": "\"dubbo-go源码笔记（二）客户端调用过程\"",
    "linkTitle": "\"dubbo-go源码笔记（二）客户端调用过程\"",
    "date": "2021-01-15",
    "description": ">",
    "随着微服务架构的流行，许多高性能 rpc 框架应运而生，由阿里开源的 dubbo 框架 go 语言版本的 dubbo-go 也成为了众多开发者不错的选择。本文将介绍 dubbo-go 框架的基本使用方法，以及从 export 调用链的角度进行 server 端源码导读，希望能引导读者进一步认识这款框架。": ""
  }
}