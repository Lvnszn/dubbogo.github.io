{
  "filename": "what's-new-in -dubbo-go-v1.5.1.md",
  "__html": "<h1><a href=\"https://www.oschina.net/news/118469/dubbo-go-1-5-1-released\">Dubbo-go v1.5.1 发布，Apache Dubbo 的 Go 实现</a></h1>\n<p>Dubbo-go 团队近期发布了 Dubbo-go v1.5.1，Dubbo-go 是 Apache Dubbo 项目的 Go 实现。</p>\n<p>根据团队的介绍，虽然 v1.5.1 是 v1.5 的一个子版本，但相比于 v1.5.0， 社区还是投入了很大人力添加了如下重大改进。</p>\n<h2>1 应用维度注册模型</h2>\n<p>在新模型 release 后，团队发现 Provider 每个 URL 发布元数据都会注册 ServiceInstance，影响性能需要优化。</p>\n<p>优化方案是： 去除 ServiceDiscoveryRegistry 中注册 ServiceInstance 的代码，在 config_loader 中的 loadProviderConfig 方法的最后注册 ServiceInstance 具体步骤：</p>\n<p>1、获取所有注册的 Registry，过滤出 ServiceDiscoveryRegistry，拿取所有 ServiceDiscovery。\n2、创建 ServiceInstance。\n3、每个 ServiceDiscovery 注册 ServiceInstance。</p>\n<p>保证 Provider 在注册成功之后，才暴露元数据信息。</p>\n<h2>2 支持基于 Seata 的事务</h2>\n<p>基于 Seata 扩展实现。通过增加过滤器，在服务端接收 xid 并结合 seata-golang 达到支持分布式事务的目的。 从而使 Dubbo-go 在分布式场景下，让用户有更多的选择，能适应更多的个性化场景。</p>\n<p>开发团队在 dubbo-samples 中给出了 事务测试用例 。</p>\n<h2>3 多注册中心集群负载均衡</h2>\n<p>对于多注册中心订阅的场景，选址时的多了一层注册中心集群间的负载均衡：</p>\n<p>在 Cluster Invoker 这一级，支持的选址策略有：</p>\n<ul>\n<li>指定优先级</li>\n<li>同 zone 优先</li>\n<li>权重轮询</li>\n</ul>\n<h2>3 传输链路安全性</h2>\n<p>该版本在传输链路的安全性上做了尝试，对于内置的 Dubbo getty Server 提供了基于 TLS 的安全链路传输机制。</p>\n<p>为尽可能保证应用启动的灵活性，TLS Cert 的指定通过配置文件方式，具体请参见 Dubbo-go 配置读取规则与 TLS 示例：</p>\n<h2>4 路由功能增强</h2>\n<p>本次路由功能重点支持了 动态标签路由 和 应用/服务级条件路由。</p>\n<h3>4.1 动态标签路由</h3>\n<p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p>\n<p>标签主要是指对 Provider 端应用实例的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标，其中动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p>\n<h3>4.1.1 动态规则打标</h3>\n<p>可随时在服务治理控制台下发标签归组规则</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-comment\"># governance-tagrouter-provider应用增加了两个标签分组tag1和tag2</span>\n<span class=\"hljs-comment\"># tag1包含一个实例 127.0.0.1:20880</span>\n<span class=\"hljs-comment\"># tag2包含一个实例 127.0.0.1:20881</span>\n<span class=\"hljs-meta\">---</span>\n  <span class=\"hljs-attr\">force:</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-attr\">runtime:</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">governance-tagrouter-provider</span>\n  <span class=\"hljs-attr\">tags:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">tag1</span>\n      <span class=\"hljs-attr\">addresses:</span> <span class=\"hljs-string\">[\"127.0.0.1:20880\"]</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">tag2</span>\n      <span class=\"hljs-attr\">addresses:</span> <span class=\"hljs-string\">[\"127.0.0.1:20881\"]</span>\n <span class=\"hljs-string\">...</span>\n</code></pre>\n<h3>4.1.2 静态规则打标</h3>\n<p>可以在 server 配置文件的 tag 字段里设置</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">\"UserProvider\":</span>\n    <span class=\"hljs-attr\">registry:</span> <span class=\"hljs-string\">\"hangzhouzk\"</span>\n    <span class=\"hljs-attr\">protocol:</span> <span class=\"hljs-string\">\"dubbo\"</span>\n    <span class=\"hljs-attr\">interface:</span> <span class=\"hljs-string\">\"com.ikurento.user.UserProvider\"</span>\n    <span class=\"hljs-attr\">loadbalance:</span> <span class=\"hljs-string\">\"random\"</span>\n    <span class=\"hljs-attr\">warmup:</span> <span class=\"hljs-string\">\"100\"</span>\n    <span class=\"hljs-attr\">tag:</span> <span class=\"hljs-string\">\"beijing\"</span>\n    <span class=\"hljs-attr\">cluster:</span> <span class=\"hljs-string\">\"failover\"</span>\n    <span class=\"hljs-attr\">methods:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"GetUser\"</span>\n        <span class=\"hljs-attr\">retries:</span> <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-attr\">loadbalance:</span> <span class=\"hljs-string\">\"random\"</span>\n</code></pre>\n<p>consumer 添加 tag 至 attachment 即可</p>\n<pre><code class=\"language-go\">ctx := context.Background()\nattachment := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>)\nattachment[<span class=\"hljs-string\">\"dubbo.tag\"</span>] = <span class=\"hljs-string\">\"beijing\"</span>\nctx = context.WithValue(ctx, constant.AttachmentKey, attachment)\nerr := userProvider.GetUser(ctx, []<span class=\"hljs-keyword\">interface</span>{}{<span class=\"hljs-string\">\"A001\"</span>}, user)\n</code></pre>\n<p>请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p>\n<h3>4.1.3 规则详解</h3>\n<p>格式\nKey 明确规则体作用到哪个应用。必填。\nenabled=true 当前路由规则是否生效，可不填，缺省生效。\nforce=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。\nruntime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。\npriority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。\ntags 定义具体的标签分组内容，可定义任意 n（n&gt;=1）个标签并为每个标签指定实例列表。必填\nname， 标签名称\naddresses， 当前标签包含的实例列表\n降级约定\nrequest.tag=tag1 时优先选择 标记了 tag=tag1 的 provider。若集群中不存在与请求标记对应的服务，默认将降级请求 tag 为空的 provider；如果要改变这种默认行为，即找不到匹配 tag1 的 provider 返回异常，需设置 request.tag.force=true。\nrequest.tag 未设置时，只会匹配 tag 为空的 provider。即使集群中存在可用的服务，若 tag 不匹配也就无法调用，这与约定 1 不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签/携带其他种类标签的请求永远无法访问到其他标签的服务。</p>\n<h2>4.2 应用/服务级条件路由</h2>\n<p>可以在路由规则配置中配置多个条件路由及其粒度</p>\n<p>Sample:</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-comment\"># dubbo router yaml configure file</span>\n<span class=\"hljs-attr\">routerRules:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">scope:</span> <span class=\"hljs-string\">application</span>\n    <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">BDTService</span>\n    <span class=\"hljs-attr\">priority:</span> <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-attr\">force:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">conditions:</span> <span class=\"hljs-string\">[\"host</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.199</span><span class=\"hljs-number\">.208</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">host</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.199</span><span class=\"hljs-number\">.208</span> <span class=\"hljs-string\">\"]\n  - scope: service\n    key: com.ikurento.user.UserProvider\n    priority: 1\n    force: true\n    conditions: [\"</span><span class=\"hljs-string\">host</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.199</span><span class=\"hljs-number\">.208</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">host</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.199</span><span class=\"hljs-number\">.208</span> <span class=\"hljs-string\">\"]\n</span></code></pre>\n<h3>4.2.1 规则详解</h3>\n<h4>各字段含义</h4>\n<ul>\n<li>scope 表示路由规则的作用粒度，scope 的取值会决定 key 的取值。必填。\n<ul>\n<li>service 服务粒度</li>\n<li>application 应用粒度</li>\n</ul>\n</li>\n<li>Key 明确规则体作用在哪个服务或应用。必填。\n<ul>\n<li>scope=service 时，key 取值为[{group}/]{service}[:{version}]的组合</li>\n<li>scope=application 时，key 取值为 application 名称</li>\n</ul>\n</li>\n<li>enabled=true 当前路由规则是否生效，可不填，缺省生效。</li>\n<li>force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。</li>\n<li>runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。</li>\n<li>priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。</li>\n<li>conditions 定义具体的路由规则内容。必填。</li>\n</ul>\n<h2>5 回顾与展望</h2>\n<p>Dubbo-go 处于一个比较稳定成熟的状态。目前新版本正处于往云原生方向的尝试，应用服务维度注册是首先推出的功能，这是一个和之前模型完全不一样的新注册模型。该版本是朝云原生迈进新一步的关键版本。除此之外，包含在该版本也有一些之前提到的优化。</p>\n<p>下一个版本 v1.5.2，本次的关注重点以通信模型改进为主，除此之外，与 2.7.x 的兼容性、易用性及质量保证也是本次关注的信息。</p>\n<p>在服务发现，会支持更加多的方式，如：文件、Consul。 从而使 Dubbo-go 在服务发现场景下，让用户有更多的选择，能适应更多的个性化场景。</p>\n<p>另外 易用性及质量保证，主要关注的是 samples 与自动化构建部分。可降低用户上手 Dubbo-go 的难度，提高代码质量。</p>\n<p>目前下一个版本正在紧锣密鼓的开发中，具体规划及任务清单，都已经在 Github 上体现。</p>\n<p>更多信息：<a href=\"https://github.com/apache/dubbo-go/releases/tag/v1.5.1\">https://github.com/apache/dubbo-go/releases/tag/v1.5.1</a></p>\n",
  "link": "/zh-cn/docs/md/interview/what's-new-in -dubbo-go-v1.5.1.html",
  "meta": {
    "title": "Dubbo-go v1.5.1 发布，Apache Dubbo 的 Go 实现",
    "keywords": "dubbogo go",
    "description": "dubbo-go的v1.5.0版本介绍"
  }
}